generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum UserRole {
  SUPER_ADMIN
  ADMIN
  HOCA
  USER
  GUEST
}

enum NotificationType {
  EPISODE_PUBLISHED
  COMMENT_REPLY
  SYSTEM
  NEW_FOLLOWER
  MENTION
}

enum AnalyticsEventType {
  PODCAST_PLAY
  PODCAST_COMPLETE
  PODCAST_FOLLOW
  PODCAST_SHARE
  STREAM_JOIN
  EPISODE_DOWNLOAD
  SEARCH_QUERY
}

enum StreamStatus {
  SCHEDULED
  LIVE
  ENDED
  CANCELLED
}

enum DownloadStatus {
  PENDING
  COMPLETED
  FAILED
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
  ESCALATED
}

enum ScheduleStatus {
  PENDING
  PUBLISHED
  FAILED
  CANCELLED
}

enum CollaboratorRole {
  CO_HOST
  EDITOR
  CONTRIBUTOR
  GUEST
}

enum CollaboratorStatus {
  PENDING
  ACCEPTED
  REJECTED
  REMOVED
}

// Push Notification Enums
enum DevicePlatform {
  IOS
  ANDROID
  WEB
}

enum PushProviderType {
  ONESIGNAL
  FIREBASE
}

enum PushTargetType {
  ALL
  SEGMENT
  USER_IDS
  TOPIC
}

enum PushStatus {
  PENDING
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum SocialProvider {
  GOOGLE
  APPLE
  FACEBOOK
}

// SMS Enums
enum SmsProvider {
  NETGSM
  TWILIO
}

// Hoca Application Status
enum HocaApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum OtpType {
  ADMIN_LOGIN
  PHONE_VERIFY
}

enum SmsType {
  OTP
  NOTIFICATION
}

enum SmsStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

// Live Stream Enums
enum LiveStreamStatus {
  SCHEDULED
  PREPARING
  LIVE
  PAUSED
  ENDED
  CANCELLED
}

// ==================== MODELS ====================

model User {
  id               String    @id @default(uuid())
  tenantId         String
  tenant           Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  email            String
  passwordHash     String
  refreshTokenHash String?
  name             String?
  role             UserRole  @default(USER)
  isActive         Boolean   @default(true)
  emailVerified    Boolean   @default(false)
  phone            String?   @unique
  phoneVerified    Boolean   @default(false)
  phoneVerifiedAt  DateTime?
  avatarUrl        String?
  bio              String?   @db.VarChar(500)
  preferences      Json?     @default("{}")
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  ownedPodcasts         Podcast[]             @relation("PodcastOwner")
  episodes              Episode[]             @relation("EpisodeHosts")
  follows               Follow[]
  comments              Comment[]
  notifications         Notification[]
  events                AnalyticsEvent[]
  progresses            ListeningProgress[]
  streamingSessions     StreamingSession[]    @relation("SessionHosts")
  hocas                 Hoca[]
  passwordResets        PasswordReset[]
  emailVerifications    EmailVerification[]
  favorites             Favorite[]
  playlists             Playlist[]
  downloads             Download[]
  auditLogs             AuditLog[]
  reviews               Review[]
  reviewHelpfulVotes    ReviewHelpfulVote[]
  moderationReports     ModerationQueue[]     @relation("ReportedBy")
  moderations           ModerationQueue[]     @relation("Moderator")
  podcastCollabs        PodcastCollaborator[] @relation("CollaboratorUser")
  invitedCollaborations PodcastCollaborator[] @relation("CollaboratorInviter")
  storageAssets         StorageAsset[]
  devices               UserDevice[]
  pushSettings          UserPushSettings?
  socialConnections     SocialConnection[]
  hostedLiveStreams     LiveStream[]          @relation("LiveStreamHost")
  liveListeners         LiveListener[]
  loginHistory          LoginHistory[]

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([email])
  @@index([phone])
  @@index([role])
  @@index([isActive])
}

model Tenant {
  id          String   @id @default(uuid())
  name        String
  slug        String   @unique
  description String?
  logoUrl     String?
  isActive    Boolean  @default(true)
  settings    Json?    @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users              User[]
  podcasts           Podcast[]
  categories         Category[]
  hocas              Hoca[]
  notifications      Notification[]
  events             AnalyticsEvent[]
  episodes           Episode[]
  follows            Follow[]
  comments           Comment[]
  progresses         ListeningProgress[]
  assets             StorageAsset[]
  sessions           StreamingSession[]
  favorites          Favorite[]
  playlists          Playlist[]
  playlistEpisodes   PlaylistEpisode[]
  downloads          Download[]
  reviews            Review[]
  reviewHelpfulVotes ReviewHelpfulVote[]
  auditLogs          AuditLog[]
  scheduledEpisodes  ScheduledEpisode[]
  moderations        ModerationQueue[]
  userDevices        UserDevice[]
  userPushSettings   UserPushSettings[]
  pushConfig         PushConfig?
  pushLogs           PushNotificationLog[]
  socialAuthConfig   SocialAuthConfig?
  smsConfig          SmsConfig?
  smsLogs            SmsLog[]
  liveStreams        LiveStream[]
  emailConfig        EmailConfig?
  emailLogs          EmailLog[]
  storageConfig      StorageConfig?
  apiKeys            TenantApiKey[]
  loginHistory       LoginHistory[]

  @@index([slug])
  @@index([isActive])
}

model Podcast {
  id            String    @id @default(uuid())
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  ownerId       String
  owner         User      @relation("PodcastOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  hocaId        String?
  hoca          Hoca?     @relation(fields: [hocaId], references: [id], onDelete: SetNull)
  title         String
  slug          String
  description   String?   @db.Text
  coverImageUrl String?
  language      String?   @default("tr")
  isPublished   Boolean   @default(false)
  isExplicit    Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  publishedAt   DateTime?

  episodes         Episode[]
  follows          Follow[]
  categories       PodcastCategory[]
  events           AnalyticsEvent[]
  sessions         StreamingSession[]
  favorites        Favorite[]
  reviews          Review[]
  collaborators    PodcastCollaborator[]
  storageAssets    StorageAsset[]
  moderationQueues ModerationQueue[]
  notifications    Notification[]

  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([ownerId])
  @@index([hocaId])
  @@index([isPublished])
  @@index([publishedAt])
  @@index([tenantId, isPublished])
}

model Episode {
  id            String    @id @default(uuid())
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  podcastId     String
  podcast       Podcast   @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  hostId        String?
  host          User?     @relation("EpisodeHosts", fields: [hostId], references: [id], onDelete: SetNull)
  title         String
  slug          String
  description   String?   @db.Text
  duration      Int
  audioUrl      String
  audioMimeType String?   @default("audio/mpeg")
  publishedAt   DateTime?
  isPublished   Boolean   @default(false)
  isExplicit    Boolean   @default(false)
  episodeNumber Int?
  seasonNumber  Int?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  comments         Comment[]
  progresses       ListeningProgress[]
  events           AnalyticsEvent[]
  sessions         StreamingSession[]
  favorites        Favorite[]
  playlistItems    PlaylistEpisode[]
  downloads        Download[]
  scheduledPublish ScheduledEpisode?
  storageAssets    StorageAsset[]
  moderationQueues ModerationQueue[]
  notifications    Notification[]

  @@unique([podcastId, slug])
  @@index([tenantId])
  @@index([podcastId])
  @@index([hostId])
  @@index([publishedAt])
  @@index([isPublished])
  @@index([tenantId, isPublished])
  @@index([podcastId, isPublished])
}

model Category {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String
  slug        String
  description String?  @db.VarChar(1000)
  iconUrl     String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  podcasts PodcastCategory[]

  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([sortOrder])
}

model PodcastCategory {
  podcastId  String
  categoryId String

  podcast  Podcast  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([podcastId, categoryId])
  @@index([categoryId])
  @@index([podcastId])
}

model Follow {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  podcastId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  podcast Podcast @relation(fields: [podcastId], references: [id], onDelete: Cascade)

  @@unique([userId, podcastId])
  @@index([tenantId])
  @@index([userId])
  @@index([podcastId])
  @@index([tenantId, userId])
  @@index([tenantId, podcastId])
}

model Comment {
  id        String    @id @default(uuid())
  tenantId  String
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  episodeId String
  episode   Episode   @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentId  String?
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies   Comment[] @relation("CommentReplies")
  content   String    @db.VarChar(5000)
  isEdited  Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  moderationQueues ModerationQueue[]

  @@index([tenantId])
  @@index([episodeId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@index([tenantId, episodeId, createdAt])
}

model Notification {
  id        String           @id @default(uuid())
  tenantId  String
  tenant    Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String?
  payload   Json
  readAt    DateTime?
  createdAt DateTime         @default(now())
  podcastId String?
  podcast   Podcast?         @relation(fields: [podcastId], references: [id], onDelete: SetNull)
  episodeId String?
  episode   Episode?         @relation(fields: [episodeId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([userId])
  @@index([type])
  @@index([readAt])
  @@index([createdAt])
  @@index([userId, readAt])
  @@index([podcastId])
  @@index([episodeId])
}

model AnalyticsEvent {
  id         String             @id @default(uuid())
  tenantId   String
  tenant     Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId     String?
  user       User?              @relation(fields: [userId], references: [id], onDelete: SetNull)
  podcastId  String?
  podcast    Podcast?           @relation(fields: [podcastId], references: [id], onDelete: SetNull)
  episodeId  String?
  episode    Episode?           @relation(fields: [episodeId], references: [id], onDelete: SetNull)
  eventType  AnalyticsEventType
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  occurredAt DateTime           @default(now())

  @@index([tenantId])
  @@index([eventType])
  @@index([userId])
  @@index([podcastId])
  @@index([episodeId])
  @@index([occurredAt])
  @@index([tenantId, eventType, occurredAt])
}

model ListeningProgress {
  id              String   @id @default(uuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodeId       String
  episode         Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  progressSeconds Int      @default(0)
  completed       Boolean  @default(false)
  playCount       Int      @default(1)
  lastPlayedAt    DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdAt       DateTime @default(now())

  @@unique([userId, episodeId])
  @@index([tenantId])
  @@index([userId])
  @@index([lastPlayedAt])
  @@index([tenantId, userId, lastPlayedAt])
  @@index([tenantId, episodeId])
}

model Hoca {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId      String?  @unique
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  name        String
  bio         String?  @db.Text
  avatarUrl   String?
  expertise   String?
  socialLinks Json?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  podcasts      Podcast[]
  storageAssets StorageAsset[]

  @@index([tenantId])
  @@index([userId])
  @@index([isActive])
}

model StorageAsset {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  podcastId String?
  podcast   Podcast? @relation(fields: [podcastId], references: [id], onDelete: SetNull)
  episodeId String?
  episode   Episode? @relation(fields: [episodeId], references: [id], onDelete: SetNull)
  hocaId    String?
  hoca      Hoca?    @relation(fields: [hocaId], references: [id], onDelete: SetNull)
  bucket    String
  objectKey String
  url       String
  mimeType  String?
  sizeBytes BigInt?
  metadata  Json?
  createdAt DateTime @default(now())

  @@unique([bucket, objectKey])
  @@index([tenantId])
  @@index([userId])
  @@index([podcastId])
  @@index([episodeId])
  @@index([hocaId])
  @@index([bucket])
}

model StreamingSession {
  id          String       @id @default(uuid())
  tenantId    String
  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  hostId      String
  host        User         @relation("SessionHosts", fields: [hostId], references: [id], onDelete: Cascade)
  podcastId   String?
  podcast     Podcast?     @relation(fields: [podcastId], references: [id], onDelete: SetNull)
  episodeId   String?
  episode     Episode?     @relation(fields: [episodeId], references: [id], onDelete: SetNull)
  title       String?
  description String?
  status      StreamStatus @default(SCHEDULED)
  viewerCount Int          @default(0)
  startedAt   DateTime?
  endedAt     DateTime?
  scheduledAt DateTime?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([tenantId])
  @@index([hostId])
  @@index([status])
  @@index([scheduledAt])
}

// ==================== AUTH TOKENS ====================

model PasswordReset {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String    @unique
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  ipAddress String?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model EmailVerification {
  id         String    @id @default(uuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token      String    @unique
  email      String?
  expiresAt  DateTime
  verified   Boolean   @default(false)
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ==================== USER CONTENT ====================

model Favorite {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  podcastId String?
  podcast   Podcast? @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  episodeId String?
  episode   Episode? @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, podcastId], map: "Favorite_user_podcast_unique")
  @@unique([userId, episodeId], map: "Favorite_user_episode_unique")
  @@index([tenantId])
  @@index([userId])
  @@index([podcastId])
  @@index([episodeId])
  @@index([tenantId, userId, createdAt])
}

model Playlist {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String   @db.VarChar(100)
  description String?  @db.VarChar(500)
  isPublic    Boolean  @default(false)
  coverUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  episodes PlaylistEpisode[]

  @@index([tenantId])
  @@index([userId])
  @@index([isPublic])
}

model PlaylistEpisode {
  id         String   @id @default(uuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  playlistId String
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  episodeId  String
  episode    Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  order      Int      @default(0)
  addedAt    DateTime @default(now())

  @@unique([playlistId, episodeId])
  @@index([tenantId])
  @@index([playlistId])
  @@index([episodeId])
  @@index([order])
}

model Download {
  id           String         @id @default(uuid())
  tenantId     String
  tenant       Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId       String
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  episodeId    String
  episode      Episode        @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  downloadUrl  String?
  fileSize     BigInt?
  status       DownloadStatus @default(PENDING)
  errorMessage String?
  createdAt    DateTime       @default(now())
  completedAt  DateTime?

  @@unique([userId, episodeId])
  @@index([tenantId])
  @@index([userId])
  @@index([episodeId])
  @@index([status])
  @@index([tenantId, userId, status])
}

// ==================== ADMIN & AUDIT ====================

model AuditLog {
  id         String   @id @default(uuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  action     String
  entityType String
  entityId   String?
  oldValues  Json?
  newValues  Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  @@index([tenantId])
  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([entityId])
  @@index([createdAt])
  @@index([entityType, entityId])
}

// ==================== REVIEWS & RATINGS ====================
// NOTE: Review.rating must be between 1-5 (validate in application layer)

model Review {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  podcastId String
  podcast   Podcast  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  rating    Int      @db.SmallInt
  title     String?  @db.VarChar(200)
  content   String?  @db.VarChar(5000)
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  helpfulVotes ReviewHelpfulVote[]

  @@unique([userId, podcastId])
  @@index([tenantId])
  @@index([podcastId])
  @@index([userId])
  @@index([rating])
  @@index([isPublic])
  @@index([createdAt])
  @@index([tenantId, podcastId, rating])
}

model ReviewHelpfulVote {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewId  String
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  isHelpful Boolean
  createdAt DateTime @default(now())

  @@unique([userId, reviewId])
  @@index([tenantId])
  @@index([reviewId])
  @@index([userId])
}

// ==================== SCHEDULING ====================
// NOTE: ScheduledEpisode.retryCount should not exceed 5 (validate in application layer)

model ScheduledEpisode {
  id          String         @id @default(uuid())
  tenantId    String
  tenant      Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  episodeId   String         @unique
  episode     Episode        @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  scheduledAt DateTime
  publishedAt DateTime?
  status      ScheduleStatus @default(PENDING)
  retryCount  Int            @default(0)
  lastError   String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([tenantId])
  @@index([scheduledAt])
  @@index([status])
  @@index([status, scheduledAt])
}

// ==================== MODERATION ====================

model ModerationQueue {
  id           String           @id @default(uuid())
  tenantId     String
  tenant       Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  entityType   String
  entityId     String
  reportedBy   String?
  reportedUser User?            @relation("ReportedBy", fields: [reportedBy], references: [id], onDelete: SetNull)
  reason       String?          @db.VarChar(1000)
  status       ModerationStatus @default(PENDING)
  priority     Int              @default(0)
  moderatedBy  String?
  moderator    User?            @relation("Moderator", fields: [moderatedBy], references: [id], onDelete: SetNull)
  moderatedAt  DateTime?
  notes        String?          @db.Text
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  podcastId    String?
  podcast      Podcast?         @relation(fields: [podcastId], references: [id], onDelete: SetNull)
  episodeId    String?
  episode      Episode?         @relation(fields: [episodeId], references: [id], onDelete: SetNull)
  commentId    String?
  comment      Comment?         @relation(fields: [commentId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([entityType])
  @@index([entityId])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@index([entityType, status])
  @@index([podcastId])
  @@index([episodeId])
  @@index([commentId])
}

// ==================== COLLABORATION ====================

model PodcastCollaborator {
  id            String             @id @default(uuid())
  podcastId     String
  podcast       Podcast            @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  userId        String
  user          User               @relation("CollaboratorUser", fields: [userId], references: [id], onDelete: Cascade)
  role          CollaboratorRole   @default(CONTRIBUTOR)
  permissions   Json?
  status        CollaboratorStatus @default(PENDING)
  invitedAt     DateTime           @default(now())
  acceptedAt    DateTime?
  invitedBy     String?
  invitedByUser User?              @relation("CollaboratorInviter", fields: [invitedBy], references: [id], onDelete: SetNull)

  @@unique([podcastId, userId])
  @@index([podcastId])
  @@index([userId])
  @@index([status])
  @@index([invitedBy])
}

// ==================== PUSH NOTIFICATIONS ====================

model UserDevice {
  id           String         @id @default(uuid())
  tenantId     String
  tenant       Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId       String
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceToken  String
  platform     DevicePlatform
  deviceName   String?
  appVersion   String?
  osVersion    String?
  isActive     Boolean        @default(true)
  lastActiveAt DateTime       @default(now())
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@unique([tenantId, deviceToken])
  @@index([tenantId])
  @@index([userId])
  @@index([platform])
  @@index([isActive])
  @@index([tenantId, userId, isActive])
}

model UserPushSettings {
  id                   String   @id @default(uuid())
  tenantId             String
  tenant               Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId               String   @unique
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  enablePush           Boolean  @default(true)
  newEpisodes          Boolean  @default(true)
  comments             Boolean  @default(true)
  likes                Boolean  @default(true)
  follows              Boolean  @default(true)
  systemUpdates        Boolean  @default(true)
  marketingPromotions  Boolean  @default(false)
  quietHoursEnabled    Boolean  @default(false)
  quietHoursStart      String?  // HH:mm format
  quietHoursEnd        String?  // HH:mm format
  timezone             String   @default("UTC")
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([tenantId])
  @@index([userId])
  @@index([enablePush])
}

model PushConfig {
  id                   String           @id @default(uuid())
  tenantId             String           @unique
  tenant               Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  provider             PushProviderType @default(ONESIGNAL)
  isEnabled            Boolean          @default(false)
  // Encrypted credentials - OneSignal
  oneSignalAppId       String?
  oneSignalApiKey      String?          // Encrypted
  // Encrypted credentials - Firebase
  firebaseProjectId    String?
  firebaseCredentials  String?          @db.Text // Encrypted JSON
  // Web Push VAPID Keys
  vapidPublicKey       String?          // Public key for web clients
  vapidPrivateKey      String?          // Encrypted private key
  vapidSubject         String?          // mailto: or URL for VAPID
  // Settings
  defaultTitle         String?
  defaultIcon          String?
  defaultBadge         String?
  rateLimitPerMinute   Int              @default(1000)
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  @@index([tenantId])
  @@index([provider])
  @@index([isEnabled])
}

model PushNotificationLog {
  id              String         @id @default(uuid())
  tenantId        String
  tenant          Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  title           String
  body            String
  data            Json?
  targetType      PushTargetType
  targetIds       String[]       // User IDs, segment names, or topic names
  totalRecipients Int            @default(0)
  successCount    Int            @default(0)
  failureCount    Int            @default(0)
  status          PushStatus     @default(PENDING)
  provider        PushProviderType?
  providerMsgId   String?        // External message ID from provider
  errorMessage    String?
  sentAt          DateTime?
  scheduledAt     DateTime?
  createdBy       String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([tenantId])
  @@index([status])
  @@index([targetType])
  @@index([createdAt])
  @@index([sentAt])
  @@index([tenantId, status])
  @@index([tenantId, createdAt])
}

// ==================== SOCIAL AUTH ====================

model SocialAuthConfig {
  id                   String   @id @default(uuid())
  tenantId             String?  @unique
  tenant               Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  // Google OAuth
  googleEnabled        Boolean  @default(false)
  googleClientId       String?
  googleClientSecret   String?  // Encrypted
  googleCallbackUrl    String?
  // Apple Sign In (future)
  appleEnabled         Boolean  @default(false)
  appleClientId        String?
  appleTeamId          String?
  appleKeyId           String?
  applePrivateKey      String?  @db.Text // Encrypted
  // Facebook (future)
  facebookEnabled      Boolean  @default(false)
  facebookAppId        String?
  facebookAppSecret    String?  // Encrypted
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([tenantId])
}

model SocialConnection {
  id           String         @id @default(uuid())
  userId       String
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider     SocialProvider
  providerId   String         // Provider's user ID (e.g., Google sub)
  email        String
  displayName  String?
  avatarUrl    String?
  accessToken  String?        @db.Text // Encrypted
  refreshToken String?        @db.Text // Encrypted
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@unique([provider, providerId])
  @@unique([userId, provider])
  @@index([userId])
  @@index([email])
}

// ==================== SMS & OTP ====================

model SmsConfig {
  id              String      @id @default(cuid())
  tenantId        String?     @unique
  tenant          Tenant?     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Provider
  provider        SmsProvider @default(NETGSM)
  isEnabled       Boolean     @default(false)

  // NetGSM Credentials
  netgsmUsercode  String?
  netgsmPassword  String?     // Encrypted
  netgsmMsgHeader String?

  // Twilio Credentials
  twilioAccountSid    String?
  twilioAuthToken     String?   // Encrypted
  twilioFromNumber    String?
  twilioVerifyServiceSid String?

  // OTP Settings
  otpLength       Int         @default(6)
  otpExpiryMins   Int         @default(5)
  maxAttempts     Int         @default(3)
  resendCooldown  Int         @default(60)

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([tenantId])
}

model OtpVerification {
  id          String    @id @default(cuid())
  phone       String
  code        String    // Hashed OTP
  type        OtpType
  attempts    Int       @default(0)
  verified    Boolean   @default(false)
  verifiedAt  DateTime?
  expiresAt   DateTime
  createdAt   DateTime  @default(now())

  @@index([phone, type])
  @@index([expiresAt])
}

model SmsLog {
  id          String      @id @default(cuid())
  tenantId    String?
  tenant      Tenant?     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phone       String
  message     String      @db.Text
  type        SmsType
  provider    SmsProvider
  providerId  String?
  status      SmsStatus   @default(PENDING)
  errorMsg    String?
  sentAt      DateTime?
  createdAt   DateTime    @default(now())

  @@index([tenantId])
  @@index([phone, createdAt])
  @@index([status])
}

// ==================== HOCA APPLICATION ====================
// Hoca başvuru sistemi - telefon doğrulaması sonrası başvuru

model HocaApplication {
  id                  String                @id @default(cuid())
  tenantId            String

  // Başvuru bilgileri
  phone               String                @unique
  phoneVerified       Boolean               @default(false)
  phoneVerifiedAt     DateTime?

  // Kişisel bilgiler
  name                String
  email               String?
  passwordHash        String?               // Başvuru sırasında girilen şifre (onay sonrası User'a aktarılacak)
  bio                 String?               @db.Text
  avatarUrl           String?

  // Mesleki bilgiler
  expertise           String?               // Uzmanlık alanı
  organization        String?               // Görevli olduğu kurum (Diyanet, vb.)
  position            String?               // Pozisyon/Unvan
  certificateUrl      String?               // Sertifika/Diploma görseli

  // Sosyal medya
  socialLinks         Json?

  // Başvuru durumu
  status              HocaApplicationStatus @default(PENDING)
  reviewedBy          String?               // Onaylayan admin ID
  reviewedAt          DateTime?
  reviewNotes         String?               @db.Text
  rejectionReason     String?

  // Onay sonrası oluşturulan kullanıcı
  userId              String?               @unique

  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt

  @@index([tenantId])
  @@index([phone])
  @@index([status])
  @@index([tenantId, status])
}

// ==================== LIVE STREAMING MODELS ====================

// Canlı yayın oturumu
model LiveStream {
  id              String           @id @default(cuid())
  tenantId        String
  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Yayıncı (Hoca)
  hostId          String
  host            User             @relation("LiveStreamHost", fields: [hostId], references: [id], onDelete: Cascade)

  // Yayın bilgileri
  title           String
  description     String?          @db.Text

  // Teknik bilgiler
  streamKey       String           @unique @default(cuid())
  hlsUrl          String?
  hlsPath         String?

  // Durum
  status          LiveStreamStatus @default(SCHEDULED)

  // Zamanlama
  scheduledAt     DateTime?
  startedAt       DateTime?
  endedAt         DateTime?
  duration        Int?             // Saniye cinsinden

  // İstatistikler
  peakViewers     Int              @default(0)
  totalViewers    Int              @default(0)

  // Kayıt (VOD)
  recordingUrl    String?
  recordingPath   String?
  isRecorded      Boolean          @default(true)

  // İlişkiler
  rooms           LiveRoom[]
  listeners       LiveListener[]
  stats           LiveStreamStats[]

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([tenantId, status])
  @@index([hostId])
  @@index([status, scheduledAt])
  @@index([status, startedAt])
}

// Canlı yayın odaları
model LiveRoom {
  id              String         @id @default(cuid())
  streamId        String
  stream          LiveStream     @relation(fields: [streamId], references: [id], onDelete: Cascade)

  // Oda bilgileri
  roomNumber      Int
  name            String

  // Kapasite
  capacity        Int            @default(20)
  currentCount    Int            @default(0)

  // Durum
  isActive        Boolean        @default(true)

  // İlişkiler
  listeners       LiveListener[]

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@unique([streamId, roomNumber])
  @@index([streamId, isActive])
}

// Dinleyici kayıtları
model LiveListener {
  id              String       @id @default(cuid())
  streamId        String
  stream          LiveStream   @relation(fields: [streamId], references: [id], onDelete: Cascade)
  roomId          String
  room            LiveRoom     @relation(fields: [roomId], references: [id], onDelete: Cascade)

  // Kullanıcı (opsiyonel - misafir dinleyici olabilir)
  userId          String?
  user            User?        @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Session
  sessionId       String       @unique

  // Bağlantı bilgileri
  joinedAt        DateTime     @default(now())
  leftAt          DateTime?
  duration        Int?         // Saniye cinsinden

  // Cihaz bilgisi
  deviceType      String?
  userAgent       String?
  ipAddress       String?

  @@index([streamId])
  @@index([roomId])
  @@index([userId])
  @@index([sessionId])
  @@index([streamId, leftAt])
}

// Yayın istatistikleri (dakikalık snapshot)
model LiveStreamStats {
  id              String     @id @default(cuid())
  streamId        String
  stream          LiveStream @relation(fields: [streamId], references: [id], onDelete: Cascade)

  // Snapshot zamanı
  timestamp       DateTime   @default(now())

  // Metrikler
  viewerCount     Int
  roomCount       Int

  @@index([streamId, timestamp])
}

// ==================== EMAIL CONFIG ====================

enum EmailProvider {
  SMTP
  SES
  SENDGRID
}

model EmailConfig {
  id              String        @id @default(cuid())
  tenantId        String?       @unique
  tenant          Tenant?       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Provider
  provider        EmailProvider @default(SMTP)
  isEnabled       Boolean       @default(false)

  // SMTP Settings
  smtpHost        String?
  smtpPort        Int?          @default(587)
  smtpUser        String?
  smtpPassword    String?       // Encrypted
  smtpSecure      Boolean       @default(false)

  // SES Settings
  sesRegion       String?
  sesAccessKey    String?
  sesSecretKey    String?       // Encrypted

  // SendGrid Settings
  sendgridApiKey  String?       // Encrypted

  // Common Settings
  fromEmail       String?
  fromName        String?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([tenantId])
}

model EmailLog {
  id              String        @id @default(cuid())
  tenantId        String?
  tenant          Tenant?       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  toEmail         String
  toName          String?
  subject         String
  body            String?       @db.Text
  type            String        @default("NOTIFICATION")  // TEST, NOTIFICATION, OTP, etc.
  provider        EmailProvider
  providerId      String?
  status          SmsStatus     @default(PENDING)  // Reusing SmsStatus enum
  errorMsg        String?
  sentAt          DateTime?
  createdAt       DateTime      @default(now())

  @@index([tenantId])
  @@index([toEmail, createdAt])
  @@index([status])
}

// ==================== TENANT API KEYS ====================

model TenantApiKey {
  id           String    @id @default(cuid())
  tenantId     String
  tenant       Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name         String
  key          String    @unique  // Hashed API key (first 8 chars visible: sk_live_****abcd)
  keyHash      String              // Full hash for validation
  permissions  String[]  @default(["read"])
  lastUsedAt   DateTime?
  expiresAt    DateTime?
  isActive     Boolean   @default(true)
  createdBy    String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([tenantId])
  @@index([key])
  @@index([isActive])
}

// ==================== LOGIN HISTORY ====================

model LoginHistory {
  id            String    @id @default(cuid())
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress     String?
  userAgent     String?
  location      String?
  success       Boolean   @default(true)
  failureReason String?
  createdAt     DateTime  @default(now())

  @@index([tenantId])
  @@index([userId])
  @@index([createdAt])
  @@index([tenantId, createdAt])
}

// ==================== STORAGE CONFIG ====================

enum StorageProvider {
  LOCAL
  S3
  MINIO
}

model StorageConfig {
  id              String          @id @default(cuid())
  tenantId        String?         @unique
  tenant          Tenant?         @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Provider
  provider        StorageProvider @default(LOCAL)

  // Local Storage
  localPath       String?         @default("./uploads")

  // S3 Settings
  s3Bucket        String?
  s3Region        String?
  s3AccessKey     String?
  s3SecretKey     String?         // Encrypted
  s3Endpoint      String?         // For S3-compatible services

  // MinIO Settings (S3-compatible)
  minioEndpoint   String?
  minioBucket     String?
  minioAccessKey  String?
  minioSecretKey  String?         // Encrypted
  minioUseSSL     Boolean         @default(false)

  // Common Settings
  maxFileSize     BigInt?         @default(104857600) // 100MB default
  allowedMimeTypes String[]       @default(["image/*", "audio/*", "video/*"])
  publicBaseUrl   String?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([tenantId])
}
